"""
Validation System for CodeConductor
Validates code generated by Cursor against project requirements and structure
"""

import ast
from dataclasses import dataclass
from pathlib import Path
from typing import Any


@dataclass
class ValidationResult:
    """Result of code validation"""

    is_valid: bool
    score: float  # 0.0 to 1.0
    issues: list[str]
    suggestions: list[str]
    compliance: dict[str, bool]
    metrics: dict[str, Any]


class CodeValidator:
    """
    Validates generated code against project requirements and patterns
    """

    def __init__(self, project_path: str):
        self.project_path = Path(project_path)
        self.project_patterns = self._load_project_patterns()

    def _load_project_patterns(self) -> dict[str, Any]:
        """Load patterns from existing project code"""
        patterns = {
            "imports": set(),
            "decorators": set(),
            "function_patterns": [],
            "class_patterns": [],
            "error_handling": [],
            "type_hints": True,
            "docstrings": True,
        }

        # Scan existing Python files for patterns
        for py_file in self.project_path.rglob("*.py"):
            if "venv" not in str(py_file) and "test" not in str(py_file):
                try:
                    with open(py_file, encoding="utf-8") as f:
                        content = f.read()
                        self._extract_patterns_from_file(content, patterns)
                except Exception as e:
                    print(f"Warning: Could not analyze {py_file}: {e}")

        return patterns

    def _extract_patterns_from_file(self, content: str, patterns: dict[str, Any]):
        """Extract patterns from a single file"""
        try:
            tree = ast.parse(content)

            # Extract imports
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        patterns["imports"].add(alias.name)
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        patterns["imports"].add(node.module)

            # Extract function patterns
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    func_info = {
                        "name": node.name,
                        "has_type_hints": bool(
                            node.returns
                            or any(arg.annotation for arg in node.args.args)
                        ),
                        "has_docstring": ast.get_docstring(node) is not None,
                        "decorators": [
                            self._get_decorator_name(d) for d in node.decorator_list
                        ],
                    }
                    patterns["function_patterns"].append(func_info)

        except SyntaxError:
            # Skip files with syntax errors
            pass

    def _get_decorator_name(self, decorator) -> str:
        """Extract decorator name from AST node"""
        if isinstance(decorator, ast.Name):
            return decorator.id
        elif isinstance(decorator, ast.Attribute):
            return f"{decorator.value.id}.{decorator.attr}"
        elif isinstance(decorator, ast.Call):
            if isinstance(decorator.func, ast.Name):
                return decorator.func.id
            elif isinstance(decorator.func, ast.Attribute):
                return f"{decorator.func.value.id}.{decorator.func.attr}"
        return "unknown"

    def validate_generated_code(
        self, code: str, task_description: str
    ) -> ValidationResult:
        """
        Validate generated code against project requirements
        """
        issues = []
        suggestions = []
        compliance = {}
        metrics = {}

        # Parse the code
        try:
            tree = ast.parse(code)
        except SyntaxError as e:
            return ValidationResult(
                is_valid=False,
                score=0.0,
                issues=[f"Syntax error: {e}"],
                suggestions=["Fix syntax errors before validation"],
                compliance={},
                metrics={},
            )

        # 1. Check imports
        import_issues = self._validate_imports(tree)
        issues.extend(import_issues)

        # 2. Check type hints
        type_hint_issues = self._validate_type_hints(tree)
        issues.extend(type_hint_issues)

        # 3. Check docstrings
        docstring_issues = self._validate_docstrings(tree)
        issues.extend(docstring_issues)

        # 4. Check error handling
        error_handling_issues = self._validate_error_handling(tree)
        issues.extend(error_handling_issues)

        # 5. Check FastAPI patterns
        fastapi_issues = self._validate_fastapi_patterns(tree, task_description)
        issues.extend(fastapi_issues)

        # 6. Check code style
        style_issues = self._validate_code_style(code)
        issues.extend(style_issues)

        # Calculate compliance metrics
        compliance = self._calculate_compliance(tree, code)

        # Calculate overall score
        score = self._calculate_score(compliance, len(issues))

        # Generate suggestions
        suggestions = self._generate_suggestions(compliance, issues, task_description)

        # Calculate metrics
        metrics = self._calculate_metrics(tree, code)

        return ValidationResult(
            is_valid=score >= 0.7,  # 70% threshold
            score=score,
            issues=issues,
            suggestions=suggestions,
            compliance=compliance,
            metrics=metrics,
        )

    def _validate_imports(self, tree) -> list[str]:
        """Validate imports against project patterns"""
        issues = []
        used_imports = set()

        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    used_imports.add(alias.name)
            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    used_imports.add(node.module)

        # Check for common FastAPI imports
        required_imports = {"fastapi", "pydantic", "typing"}
        missing_imports = required_imports - used_imports

        if missing_imports:
            issues.append(f"Missing required imports: {', '.join(missing_imports)}")

        return issues

    def _validate_type_hints(self, tree) -> list[str]:
        """Validate type hints usage"""
        issues = []
        functions_without_types = []

        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                has_return_type = node.returns is not None
                has_param_types = any(arg.annotation for arg in node.args.args)

                if not (has_return_type or has_param_types):
                    functions_without_types.append(node.name)

        if functions_without_types:
            issues.append(
                f"Functions without type hints: {', '.join(functions_without_types)}"
            )

        return issues

    def _validate_docstrings(self, tree) -> list[str]:
        """Validate docstring usage"""
        issues = []
        functions_without_docs = []

        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                if not ast.get_docstring(node):
                    functions_without_docs.append(node.name)

        if functions_without_docs:
            issues.append(
                f"Functions without docstrings: {', '.join(functions_without_docs)}"
            )

        return issues

    def _validate_error_handling(self, tree) -> list[str]:
        """Validate error handling patterns"""
        issues = []

        # Check for HTTPException usage
        has_http_exception = False
        for node in ast.walk(tree):
            if isinstance(node, ast.Call):
                if (
                    isinstance(node.func, ast.Attribute)
                    and node.func.attr == "HTTPException"
                ):
                    has_http_exception = True
                    break

        if not has_http_exception:
            issues.append(
                "No HTTPException usage found - consider adding proper error handling"
            )

        return issues

    def _validate_fastapi_patterns(self, tree, task_description: str) -> list[str]:
        """Validate FastAPI-specific patterns"""
        issues = []

        # Check for route decorators
        has_routes = False
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                for decorator in node.decorator_list:
                    if self._get_decorator_name(decorator) in [
                        "app.get",
                        "app.post",
                        "app.put",
                        "app.delete",
                        "router.get",
                        "router.post",
                        "router.put",
                        "router.delete",
                    ]:
                        has_routes = True
                        break

        if "route" in task_description.lower() and not has_routes:
            issues.append("No FastAPI route decorators found")

        return issues

    def _validate_code_style(self, code: str) -> list[str]:
        """Validate basic code style"""
        issues = []

        # Check line length
        long_lines = [
            i + 1 for i, line in enumerate(code.split("\n")) if len(line) > 88
        ]
        if long_lines:
            issues.append(
                f"Lines too long (>88 chars): {', '.join(map(str, long_lines))}"
            )

        # Check for TODO comments
        if "TODO" in code.upper():
            issues.append("Contains TODO comments - should be addressed")

        return issues

    def _calculate_compliance(self, tree, code: str) -> dict[str, bool]:
        """Calculate compliance with various standards"""
        compliance = {
            "syntax_valid": True,
            "has_type_hints": False,
            "has_docstrings": False,
            "has_error_handling": False,
            "follows_fastapi_patterns": False,
            "code_style_ok": True,
        }

        # Check type hints
        functions_with_types = 0
        total_functions = 0
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                total_functions += 1
                if node.returns or any(arg.annotation for arg in node.args.args):
                    functions_with_types += 1

        if total_functions > 0:
            compliance["has_type_hints"] = (
                functions_with_types / total_functions
            ) >= 0.5

        # Check docstrings
        functions_with_docs = 0
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                if ast.get_docstring(node):
                    functions_with_docs += 1

        if total_functions > 0:
            compliance["has_docstrings"] = (
                functions_with_docs / total_functions
            ) >= 0.5

        # Check error handling
        for node in ast.walk(tree):
            if isinstance(node, ast.Call):
                if (
                    isinstance(node.func, ast.Attribute)
                    and node.func.attr == "HTTPException"
                ):
                    compliance["has_error_handling"] = True
                    break

        # Check FastAPI patterns
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                for decorator in node.decorator_list:
                    if self._get_decorator_name(decorator) in [
                        "app.get",
                        "app.post",
                        "router.get",
                        "router.post",
                    ]:
                        compliance["follows_fastapi_patterns"] = True
                        break

        return compliance

    def _calculate_score(self, compliance: dict[str, bool], issue_count: int) -> float:
        """Calculate overall validation score"""
        base_score = sum(compliance.values()) / len(compliance)

        # Penalize for issues
        issue_penalty = min(issue_count * 0.1, 0.3)

        return max(0.0, base_score - issue_penalty)

    def _generate_suggestions(
        self, compliance: dict[str, bool], issues: list[str], task_description: str
    ) -> list[str]:
        """Generate improvement suggestions"""
        suggestions = []

        if not compliance.get("has_type_hints"):
            suggestions.append(
                "Add type hints to function parameters and return values"
            )

        if not compliance.get("has_docstrings"):
            suggestions.append("Add docstrings to all functions")

        if not compliance.get("has_error_handling"):
            suggestions.append("Add proper error handling with HTTPException")

        if (
            not compliance.get("follows_fastapi_patterns")
            and "route" in task_description.lower()
        ):
            suggestions.append(
                "Add FastAPI route decorators (@app.get, @router.get, etc.)"
            )

        # Task-specific suggestions
        if "cache" in task_description.lower():
            suggestions.append("Consider adding cache invalidation logic")
            suggestions.append("Add Redis connection error handling")

        if "admin" in task_description.lower():
            suggestions.append("Add proper authentication checks for admin endpoints")
            suggestions.append("Consider adding audit logging")

        return suggestions

    def _calculate_metrics(self, tree, code: str) -> dict[str, Any]:
        """Calculate code metrics"""
        metrics = {
            "total_lines": len(code.split("\n")),
            "total_functions": 0,
            "total_classes": 0,
            "total_imports": 0,
            "complexity_score": 0,
        }

        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                metrics["total_functions"] += 1
            elif isinstance(node, ast.ClassDef):
                metrics["total_classes"] += 1
            elif isinstance(node, ast.Import | ast.ImportFrom):
                metrics["total_imports"] += 1

        # Simple complexity calculation
        metrics["complexity_score"] = (
            metrics["total_functions"] + metrics["total_classes"]
        )

        return metrics


def validate_cursor_output(
    generated_code: str, task_description: str, project_path: str
) -> ValidationResult:
    """
    Main function to validate code generated by Cursor
    """
    validator = CodeValidator(project_path)
    return validator.validate_generated_code(generated_code, task_description)


# Example usage
if __name__ == "__main__":
    # Test validation
    test_code = '''
from fastapi import FastAPI, HTTPException
from typing import List, Optional
from pydantic import BaseModel

app = FastAPI()

class User(BaseModel):
    id: int
    name: str
    email: str

@app.get("/users", response_model=List[User])
async def get_users():
    """Get all users"""
    return []
    '''

    result = validate_cursor_output(test_code, "Create user management endpoints", ".")
    print(f"Valid: {result.is_valid}")
    print(f"Score: {result.score:.2f}")
    print(f"Issues: {result.issues}")
    print(f"Suggestions: {result.suggestions}")
