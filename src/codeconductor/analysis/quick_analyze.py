from __future__ import annotations

import json
from pathlib import Path
from typing import Dict, List, Tuple


IGNORES = {
    ".git",
    "node_modules",
    "venv",
    ".venv",
    "env",
    "artifacts",
    "__pycache__",
    ".mypy_cache",
    ".pytest_cache",
    "dist",
    "build",
}


EXT_TO_LANG = {
    ".py": "python",
    ".ts": "typescript",
    ".tsx": "typescript",
    ".js": "javascript",
    ".jsx": "javascript",
    ".rs": "rust",
    ".go": "go",
    ".java": "java",
    ".cs": "csharp",
    ".cpp": "cpp",
    ".cxx": "cpp",
    ".cc": "cpp",
    ".h": "cpp",
    ".hpp": "cpp",
    ".sql": "sql",
    ".md": "markdown",
    ".yml": "yaml",
    ".yaml": "yaml",
    ".json": "json",
}


def _is_ignored(path: Path) -> bool:
    parts = {p.name for p in path.parents}
    return any(name in IGNORES for name in parts) or path.name in IGNORES


def scan_repo(root: Path) -> Tuple[List[Dict], Dict[str, int]]:
    files: List[Dict] = []
    lang_counts: Dict[str, int] = {}
    for p in root.rglob("*"):
        try:
            if not p.is_file():
                continue
            if _is_ignored(p):
                continue
            rel = p.relative_to(root)
            size = p.stat().st_size
            ext = p.suffix.lower()
            lang = EXT_TO_LANG.get(ext, "other")
            files.append(
                {
                    "path": str(rel).replace("\\", "/"),
                    "ext": ext,
                    "lang": lang,
                    "size": int(size),
                }
            )
            lang_counts[lang] = lang_counts.get(lang, 0) + 1
        except Exception:
            continue
    return files, lang_counts


def write_repo_map(root: Path, out_json: Path) -> Dict:
    out_json.parent.mkdir(parents=True, exist_ok=True)
    files, lang_counts = scan_repo(root)
    data = {
        "root": str(root.resolve()),
        "total_files": len(files),
        "languages": lang_counts,
        "files": files,
    }
    out_json.write_text(
        json.dumps(data, indent=2, ensure_ascii=False), encoding="utf-8"
    )
    return data


def write_state_md(repo_map: Dict, out_md: Path) -> None:
    out_md.parent.mkdir(parents=True, exist_ok=True)
    total = int(repo_map.get("total_files", 0))
    langs = repo_map.get("languages", {})
    files = repo_map.get("files", [])
    by_size = sorted(files, key=lambda f: f.get("size", 0), reverse=True)[:10]
    # language distribution in percentages
    parts = []
    for lang, cnt in sorted(langs.items(), key=lambda x: -x[1]):
        pct = (cnt / total * 100.0) if total else 0.0
        parts.append(f"- {lang}: {cnt} files ({pct:.1f}%)")

    lines = [
        "# Project State\n",
        f"Total files: {total}\n",
        "\n## Language distribution\n",
        *([s + "\n" for s in parts] or ["(none)\n"]),
        "\n## Largest files (top 10)\n",
    ]
    for f in by_size:
        lines.append(f"- {f['path']} ({f['size']} bytes)\n")
    out_md.write_text("".join(lines), encoding="utf-8")


def generate_cursorrules(repo_map: Dict) -> str:
    langs = repo_map.get("languages", {})
    has_py = langs.get("python", 0) > 0
    has_ts = langs.get("typescript", 0) > 0
    has_js = langs.get("javascript", 0) > 0

    ignore = [
        "artifacts/",
        "node_modules/",
        "venv/",
        ".venv/",
        "__pycache__/",
        ".mypy_cache/",
        ".pytest_cache/",
        "dist/",
        "build/",
    ]
    rules = [
        "# Auto-generated by CodeConductor\n",
        "# Keep context focused on source and tests; ignore generated artifacts\n\n",
        "[ignore]\n",
        *[f"{pat}\n" for pat in ignore],
        "\n[format]\n",
    ]
    if has_py:
        rules.append("python = black\n")
    if has_ts or has_js:
        rules.append("javascript = prettier\n")
        rules.append("typescript = prettier\n")
    return "".join(rules)


def propose_next_feature(repo_map: Dict, state_md_path: Path) -> str:
    langs = repo_map.get("languages", {})
    primary = next(iter(sorted(langs.items(), key=lambda x: -x[1])), ("unknown", 0))[0]
    test_hint = "pytest -q" if primary == "python" else "npm test"
    return (
        "# Next Feature Proposal\n\n"
        "- Goal: Implement a small, self-contained improvement with tests.\n"
        "- Scope: Touch only a few files; prefer adding tests first.\n"
        f"- Primary language: {primary}\n"
        "- Constraints:\n"
        "  - Keep changes minimal and reversible.\n"
        "  - Follow existing code style and linters.\n"
        f"  - Include a test plan and run `{test_hint}` locally.\n\n"
        f"Context summary: see {state_md_path.as_posix()}\n"
    )
